<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Particle Gen V5 (Zoomable)</title>

    <script src="https://cdn.tailwindcss.com"></script>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <style>
        body { margin: 0; overflow: hidden; background-color: #050505; font-family: 'Inter', sans-serif; touch-action: none; }
        
        .glass {
            background: rgba(20, 20, 20, 0.6);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        #webcam-preview {
            transform: scaleX(-1);
            object-fit: cover;
            border-radius: 8px;
            opacity: 0.8;
        }

        .loader {
            border: 3px solid rgba(255, 255, 255, 0.1);
            border-top: 3px solid #fbbf24;
            border-radius: 50%;
            width: 30px; height: 30px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin { 100% { transform: rotate(360deg); } }
        
        /* Instruksi Zoom */
        .zoom-hint {
            position: absolute;
            bottom: 80px;
            width: 100%;
            text-align: center;
            font-size: 10px;
            color: rgba(255,255,255,0.3);
            pointer-events: none;
            animation: fadeOut 5s forwards;
            animation-delay: 3s;
        }
        @keyframes fadeOut { to { opacity: 0; } }
    </style>
</head>
<body class="text-white">

    <div id="loading-screen" class="fixed inset-0 z-50 flex flex-col items-center justify-center bg-black transition-opacity duration-700">
        <div class="loader mb-4"></div>
        <div class="text-xs text-gray-500 tracking-widest">INITIALIZING CONTROLS</div>
    </div>

    <div class="fixed top-0 left-0 w-full h-full pointer-events-none z-10 p-4 flex flex-col justify-between">
        <div class="flex justify-between items-start pointer-events-auto">
            <div class="glass p-3 rounded-lg">
                <div class="text-xs font-bold text-gray-400">GESTURES</div>
                <div class="text-[10px] text-gray-500 mt-1 leading-relaxed">
                    üñê Open: Rainbow<br>
                    ‚úä Fist: Saturn<br>
                    ‚úåÔ∏è Peace: <span class="text-yellow-400 font-bold">TEXT</span><br>
                    ü§å Pinch: Heart
                </div>
            </div>
            <div class="glass p-1 rounded-lg w-20 h-14 relative">
                <video id="webcam-preview" class="w-full h-full bg-black" playsinline muted></video>
                <div id="tracking-status" class="absolute bottom-1 right-1 w-2 h-2 bg-red-500 rounded-full"></div>
            </div>
        </div>

        <div class="zoom-hint">
            üí° Pinch to Zoom ‚Ä¢ Drag to Rotate
        </div>

        <div class="flex justify-center pointer-events-auto pb-4">
            <div id="gesture-label" class="glass px-6 py-2 rounded-full text-sm font-bold text-gray-300 tracking-wider shadow-lg transition-all">
                WAITING...
            </div>
        </div>
    </div>

    <div id="magic-modal" class="fixed inset-0 z-40 bg-black/90 hidden flex items-center justify-center p-4">
        <div class="glass p-6 rounded-xl w-full max-w-xs relative">
            <button onclick="toggleMagicModal()" class="absolute top-2 right-3 text-gray-500 text-xl">√ó</button>
            <h3 class="text-sm font-bold text-purple-400 mb-3">AI Particle Gen</h3>
            <input type="password" id="gemini-key" placeholder="API Key" class="w-full bg-white/5 border border-white/10 rounded p-2 text-xs mb-2 text-white">
            <input type="text" id="ai-prompt" placeholder="e.g. Spiral Galaxy" class="w-full bg-white/5 border border-white/10 rounded p-2 text-xs mb-3 text-white">
            <button onclick="generateAI()" id="generate-btn" class="w-full bg-purple-600/80 hover:bg-purple-600 text-white text-xs font-bold py-2 rounded">GENERATE</button>
        </div>
    </div>

    <div id="canvas-container" class="absolute inset-0 z-0 cursor-move"></div>

    <script type="module">
        import * as THREE from 'three';
        // IMPORT CONTROLS
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { FontLoader } from 'three/addons/loaders/FontLoader.js';
        import { TextGeometry } from 'three/addons/geometries/TextGeometry.js';
        import { MeshSurfaceSampler } from 'three/addons/math/MeshSurfaceSampler.js';

        const isMobile = window.innerWidth < 768;
        const PARTICLE_COUNT = isMobile ? 12000 : 25000;
        const PARTICLE_SIZE = isMobile ? 0.2 : 0.12; 
        const CAM_Z = isMobile ? 55 : 45; 

        let scene, camera, renderer, composer, geometry, points, controls; // Added controls variable
        let positions, colors, targetPositions, targetColors;
        let textPointsCache = null;
        let currentShape = 'rainbow';
        let isAIActive = false;

        async function init() {
            const container = document.getElementById('canvas-container');
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x050505, 0.001); 

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = CAM_Z;

            renderer = new THREE.WebGLRenderer({ antialias: false, powerPreference: "high-performance" });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            container.appendChild(renderer.domElement);

            // --- ADD ORBIT CONTROLS ---
            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true; // Smooth motion
            controls.dampingFactor = 0.05;
            controls.enableZoom = true;
            controls.enablePan = false; // Disable panning to keep object centered
            controls.minDistance = 10;  // Don't go too close
            controls.maxDistance = 100; // Don't go too far
            controls.autoRotate = false;

            // Particles Setup
            positions = new Float32Array(PARTICLE_COUNT * 3);
            colors = new Float32Array(PARTICLE_COUNT * 3);
            targetPositions = new Float32Array(PARTICLE_COUNT * 3);
            targetColors = new Float32Array(PARTICLE_COUNT * 3);

            setShapeRainbow();
            for(let i=0; i<PARTICLE_COUNT*3; i++) {
                positions[i] = targetPositions[i];
                colors[i] = targetColors[i];
            }

            geometry = new THREE.BufferGeometry();
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

            const material = new THREE.PointsMaterial({
                size: PARTICLE_SIZE,
                vertexColors: true,
                blending: THREE.AdditiveBlending,
                depthWrite: false,
                transparent: true,
                opacity: 1.0
            });

            points = new THREE.Points(geometry, material);
            scene.add(points);

            // Post Processing
            const renderScene = new RenderPass(scene, camera);
            const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
            bloomPass.threshold = 0.1;
            bloomPass.strength = 0.8;
            bloomPass.radius = 0.4;

            composer = new EffectComposer(renderer);
            composer.addPass(renderScene);
            composer.addPass(bloomPass);

            await prepareTextGeometry();

            animate();
            initMediaPipe();

            const loader = document.getElementById('loading-screen');
            loader.style.opacity = '0';
            setTimeout(() => loader.remove(), 700);
            window.addEventListener('resize', onWindowResize, false);
        }

        // --- SHAPE GENERATORS ---

        function setShapeRainbow() {
            const color = new THREE.Color();
            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const phi = Math.acos(-1 + (2 * i) / PARTICLE_COUNT);
                const theta = Math.sqrt(PARTICLE_COUNT * Math.PI) * phi;
                const r = 14 + Math.random() * 2;

                targetPositions[i * 3] = r * Math.cos(theta) * Math.sin(phi);
                targetPositions[i * 3 + 1] = r * Math.sin(theta) * Math.sin(phi);
                targetPositions[i * 3 + 2] = r * Math.cos(phi);

                color.setHSL((i/PARTICLE_COUNT), 0.8, 0.5);
                targetColors[i * 3] = color.r;
                targetColors[i * 3 + 1] = color.g;
                targetColors[i * 3 + 2] = color.b;
            }
        }

        function setShapeSaturn() {
            const planetC = new THREE.Color(0x0044ff);
            const ringC = new THREE.Color(0xffaa00);
            const sphereCount = Math.floor(PARTICLE_COUNT * 0.4);
            
            for (let i = 0; i < PARTICLE_COUNT; i++) {
                if (i < sphereCount) {
                    const phi = Math.acos(-1 + (2 * i) / sphereCount);
                    const theta = Math.sqrt(sphereCount * Math.PI) * phi;
                    const r = 8;
                    targetPositions[i*3] = r * Math.cos(theta) * Math.sin(phi);
                    targetPositions[i*3+1] = r * Math.sin(theta) * Math.sin(phi);
                    targetPositions[i*3+2] = r * Math.cos(phi);
                    targetColors[i*3] = planetC.r; targetColors[i*3+1] = planetC.g; targetColors[i*3+2] = planetC.b;
                } else {
                    const angle = (i - sphereCount) * 0.01;
                    const r = 11 + Math.random() * 8;
                    const x = r * Math.cos(angle);
                    const z = r * Math.sin(angle);
                    const tilt = 0.4;
                    targetPositions[i*3] = x;
                    targetPositions[i*3+1] = z * Math.sin(tilt);
                    targetPositions[i*3+2] = z * Math.cos(tilt);
                    targetColors[i*3] = ringC.r; targetColors[i*3+1] = ringC.g; targetColors[i*3+2] = ringC.b;
                }
            }
        }

        function setShapeHeart() {
            const c = new THREE.Color(0xff0044);
            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const t = Math.random() * Math.PI * 2;
                let x = 16 * Math.pow(Math.sin(t), 3);
                let y = 13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t);
                let z = (Math.random() - 0.5) * 4;
                const r = Math.sqrt(Math.random());
                x *= r; y *= r; z *= r;
                targetPositions[i*3] = x;
                targetPositions[i*3+1] = y;
                targetPositions[i*3+2] = z;
                targetColors[i*3] = c.r; targetColors[i*3+1] = c.g; targetColors[i*3+2] = c.b;
            }
        }

        async function prepareTextGeometry() {
            const loader = new FontLoader();
            return new Promise((resolve) => {
                loader.load('https://unpkg.com/three@0.160.0/examples/fonts/helvetiker_bold.typeface.json', function (font) {
                    const textGeo = new TextGeometry('I LOVE YOU\n   WULAN', {
                        font: font,
                        size: 5.0,
                        height: 0, 
                        curveSegments: 4,
                        bevelEnabled: false
                    });
                    textGeo.center();
                    const mesh = new THREE.Mesh(textGeo, new THREE.MeshBasicMaterial());
                    const sampler = new MeshSurfaceSampler(mesh).build();
                    textPointsCache = new Float32Array(PARTICLE_COUNT * 3);
                    const tempVec = new THREE.Vector3();
                    for (let i = 0; i < PARTICLE_COUNT; i++) {
                        sampler.sample(tempVec);
                        textPointsCache[i * 3] = tempVec.x;
                        textPointsCache[i * 3 + 1] = tempVec.y;
                        textPointsCache[i * 3 + 2] = tempVec.z;
                    }
                    resolve();
                });
            });
        }

        function setShapeText() {
            if (!textPointsCache) return;
            const colorTop = new THREE.Color(0xffd700);
            const colorBot = new THREE.Color(0xff00ff);

            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const px = textPointsCache[i * 3];
                const py = textPointsCache[i * 3 + 1];
                const pz = textPointsCache[i * 3 + 2];
                targetPositions[i * 3] = px;
                targetPositions[i * 3 + 1] = py;
                targetPositions[i * 3 + 2] = pz;

                if (py > 0) {
                     targetColors[i * 3] = colorTop.r; targetColors[i * 3 + 1] = colorTop.g; targetColors[i * 3 + 2] = colorTop.b;
                } else {
                     targetColors[i * 3] = colorBot.r; targetColors[i * 3 + 1] = colorBot.g; targetColors[i * 3 + 2] = colorBot.b;
                }
            }
        }

        // --- HAND TRACKING ---
        function initMediaPipe() {
            const videoElement = document.getElementById('webcam-preview');
            const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
            hands.setOptions({ maxNumHands: 1, modelComplexity: 0, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5 });
            hands.onResults((results) => {
                const status = document.getElementById('tracking-status');
                if(results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                    status.classList.replace('bg-red-500', 'bg-green-500');
                    detectGesture(results.multiHandLandmarks[0]);
                } else {
                    status.classList.replace('bg-green-500', 'bg-red-500');
                }
            });
            const cam = new Camera(videoElement, { onFrame: async () => { await hands.send({image: videoElement}); }, width: 640, height: 480 });
            cam.start();
        }

        function detectGesture(lm) {
            if(isAIActive) return;
            const label = document.getElementById('gesture-label');
            const tips = [8, 12, 16, 20];
            const fingersUp = tips.map(t => lm[t].y < lm[t-2].y);
            
            const indexUp = fingersUp[0];
            const middleUp = fingersUp[1];
            const ringUp = fingersUp[2];
            const pinkyUp = fingersUp[3];
            const pinch = Math.hypot(lm[4].x - lm[8].x, lm[4].y - lm[8].y) < 0.05;

            let shape = currentShape;
            let txt = label.innerText;
            let col = "";

            if (pinch) {
                shape = 'heart'; txt = "HEART FOR WULAN"; col = "text-pink-500";
            } else if (!indexUp && !middleUp && !ringUp && !pinkyUp) {
                shape = 'saturn'; txt = "SATURN MODE"; col = "text-blue-500";
            } else if (indexUp && middleUp && !ringUp && !pinkyUp) {
                shape = 'text'; txt = "I LOVE YOU WULAN"; col = "text-yellow-400";
            } else if (indexUp && middleUp && ringUp && pinkyUp) {
                shape = 'rainbow'; txt = "RAINBOW SPHERE"; col = "text-green-400";
            }

            if (shape !== currentShape) {
                currentShape = shape;
                label.innerText = txt;
                label.className = `glass px-6 py-2 rounded-full text-sm font-bold tracking-wider shadow-lg transition-all ${col}`;
                
                if(shape === 'heart') setShapeHeart();
                if(shape === 'saturn') setShapeSaturn();
                if(shape === 'text') setShapeText();
                if(shape === 'rainbow') setShapeRainbow();
            }
        }

        // --- AI ---
        window.toggleMagicModal = () => { document.getElementById('magic-modal').classList.toggle('hidden'); }

        window.generateAI = async () => {
            const k = document.getElementById('gemini-key').value;
            const p = document.getElementById('ai-prompt').value;
            const b = document.getElementById('generate-btn');
            if(!k || !p) return alert('Key & Prompt Needed');
            b.innerText = "...";
            try {
                const res = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash:generateContent?key=${k}`, {
                    method: 'POST', headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({contents: [{parts: [{text: `JS loop code for particles (i, count, targetPositions, targetColors) for shape: ${p}. raw math only.`}]}]})
                });
                const d = await res.json();
                let c = d.candidates[0].content.parts[0].text.replace(/```javascript|```/g, '');
                new Function('targetPositions', 'targetColors', 'count', `for(let i=0;i<count;i++){${c}}`)(targetPositions, targetColors, PARTICLE_COUNT);
                isAIActive = true; currentShape = 'ai'; toggleMagicModal();
            } catch(e){ alert('Error'); } 
            b.innerText = "GENERATE";
        }

        function animate() {
            requestAnimationFrame(animate);
            
            // UPDATE CONTROLS (Important for Damping)
            controls.update();

            for (let i = 0; i < PARTICLE_COUNT * 3; i++) {
                positions[i] += (targetPositions[i] - positions[i]) * 0.08;
                colors[i] += (targetColors[i] - colors[i]) * 0.08;
            }
            
            geometry.attributes.position.needsUpdate = true;
            geometry.attributes.color.needsUpdate = true;
            
            // Auto rotate the object slightly for effect, user can still rotate camera
            if(currentShape !== 'text') {
                points.rotation.y += 0.002;
            } else {
                points.rotation.y = Math.sin(Date.now() * 0.001) * 0.1;
            }
            
            composer.render();
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        }

        init();
    </script>
</body>
</html>
