<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Gesture Particles V3 (Clarity Update)</title>

    <script src="https://cdn.tailwindcss.com"></script>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Inter', sans-serif; touch-action: none; }
        
        .glass {
            background: rgba(255, 255, 255, 0.08);
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
            border: 1px solid rgba(255, 255, 255, 0.15);
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.2);
        }

        #webcam-preview {
            transform: scaleX(-1);
            object-fit: cover;
        }

        canvas { display: block; }

        .loader {
            border: 3px solid rgba(255, 255, 255, 0.2);
            border-radius: 50%;
            border-top: 3px solid #eab308; /* Yellow for Wulan update */
            width: 30px;
            height: 30px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
    </style>
</head>
<body class="text-white selection:bg-yellow-500 selection:text-black">

    <div id="loading-screen" class="fixed inset-0 z-50 flex flex-col items-center justify-center bg-black transition-opacity duration-700">
        <div class="loader mb-4"></div>
        <h2 class="text-lg font-bold tracking-widest animate-pulse text-yellow-400">PREPARING TEXT</h2>
        <p id="loading-text" class="text-xs text-gray-500 mt-2">Generating 3D Geometry...</p>
    </div>

    <div class="fixed top-0 left-0 w-full h-full pointer-events-none z-10 p-4 flex flex-col justify-between">
        
        <div class="flex justify-between items-start pointer-events-auto">
            <div class="glass p-3 rounded-xl max-w-[200px]">
                <h1 class="text-sm font-bold bg-clip-text text-transparent bg-gradient-to-r from-yellow-400 to-orange-500">
                    PARTICLE<span class="font-light text-white">GEN V3</span>
                </h1>
                <div class="mt-1 text-[10px] text-gray-300 leading-tight">
                    <div>üñê Open: Rainbow</div>
                    <div>‚úä Fist: Saturn</div>
                    <div>‚úåÔ∏è Peace: <b class="text-yellow-400">Wulan Text</b></div>
                    <div>ü§å Pinch: Heart</div>
                </div>
            </div>

            <div class="glass p-1 rounded-lg overflow-hidden w-24 h-16 relative shadow-lg">
                <video id="webcam-preview" class="w-full h-full bg-gray-900" playsinline muted></video>
                <div class="absolute bottom-1 right-1 w-2 h-2 bg-red-500 rounded-full" id="tracking-status"></div>
            </div>
        </div>

        <div class="flex justify-between items-end pointer-events-auto">
            <div class="glass px-4 py-2 rounded-full flex items-center gap-3 transition-all" id="gesture-box">
                <span id="gesture-label" class="text-sm font-bold text-yellow-400 leading-tight">READY</span>
            </div>

            <div class="flex gap-2">
                <button onclick="toggleMagicModal()" class="glass active:bg-white/20 transition px-4 py-2 rounded-lg flex items-center gap-2">
                    <span class="text-lg">‚ú®</span>
                    <span class="font-bold text-xs hidden sm:inline">AI Magic</span>
                </button>
                <button onclick="toggleFullScreen()" class="glass active:bg-white/20 transition p-2 rounded-lg">
                    <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 8V4m0 0h4M4 4l5 5m11-1V4m0 0h-4m4 4l-5 5M4 16v4m0 0h4m-4 0l5-5m11 5l-5-5m5 5v-4m0 4h-4"></path></svg>
                </button>
            </div>
        </div>
    </div>

    <div id="magic-modal" class="fixed inset-0 z-40 bg-black/90 backdrop-blur-sm hidden flex items-center justify-center p-4">
        <div class="glass p-6 rounded-2xl max-w-sm w-full relative transform transition-all scale-95 opacity-0" id="magic-content">
            <button onclick="toggleMagicModal()" class="absolute top-3 right-3 text-gray-400 text-xl">√ó</button>
            <h2 class="text-xl font-bold mb-1 text-purple-400">AI Generator</h2>
            <p class="text-xs text-gray-400 mb-4">Describe a shape to create code.</p>
            <div class="space-y-3">
                <input type="password" id="gemini-key" placeholder="Google Gemini API Key" class="w-full bg-white/10 border border-white/10 rounded p-2 text-sm text-white focus:border-purple-500 outline-none">
                <input type="text" id="ai-prompt" placeholder="e.g., 'Spiral Galaxy'" class="w-full bg-white/10 border border-white/10 rounded p-2 text-sm text-white focus:border-purple-500 outline-none">
                <button onclick="generateAI()" id="generate-btn" class="w-full bg-gradient-to-r from-purple-600 to-pink-600 text-white font-bold py-2 rounded-lg text-sm shadow-lg">GENERATE</button>
            </div>
        </div>
    </div>

    <div id="canvas-container" class="absolute inset-0 z-0"></div>

    <script type="module">
        import * as THREE from 'three';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { FontLoader } from 'three/addons/loaders/FontLoader.js';
        import { TextGeometry } from 'three/addons/geometries/TextGeometry.js';
        import { MeshSurfaceSampler } from 'three/addons/math/MeshSurfaceSampler.js';

        // --- OPTIMIZATION SETTINGS ---
        const isMobile = window.innerWidth < 768;
        // Slightly increased particle count for better text definition
        const PARTICLE_COUNT = isMobile ? 10000 : 22000;
        // Adjusted size for sharpness
        const PARTICLE_SIZE = isMobile ? 0.28 : 0.15;
        
        const CAM_Z = isMobile ? 50 : 40; 
        const LERP_SPEED = 0.06;

        let scene, camera, renderer, composer, geometry, points;
        let positions, colors, targetPositions, targetColors;
        let textPointsCache = null;
        let currentShape = 'rainbow';
        let isAIActive = false;

        async function init() {
            document.getElementById('loading-text').innerText = isMobile ? 
                `Mobile Optimization: ${PARTICLE_COUNT} pts` : 
                `Desktop Quality: ${PARTICLE_COUNT} pts`;

            const container = document.getElementById('canvas-container');
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x000000, 0.002);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = CAM_Z;

            renderer = new THREE.WebGLRenderer({ antialias: false, alpha: false, powerPreference: "high-performance" });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            container.appendChild(renderer.domElement);

            positions = new Float32Array(PARTICLE_COUNT * 3);
            colors = new Float32Array(PARTICLE_COUNT * 3);
            targetPositions = new Float32Array(PARTICLE_COUNT * 3);
            targetColors = new Float32Array(PARTICLE_COUNT * 3);

            setShapeRainbow();
            for(let i=0; i<PARTICLE_COUNT*3; i++) {
                positions[i] = targetPositions[i];
                colors[i] = targetColors[i];
            }

            geometry = new THREE.BufferGeometry();
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

            const material = new THREE.PointsMaterial({
                size: PARTICLE_SIZE,
                vertexColors: true,
                blending: THREE.AdditiveBlending,
                depthWrite: false,
                transparent: true,
                opacity: 0.85
            });

            points = new THREE.Points(geometry, material);
            scene.add(points);

            // Bloom Settings - Slightly stronger for text pop
            const renderScene = new RenderPass(scene, camera);
            const bloomResolution = isMobile ? new THREE.Vector2(window.innerWidth/2, window.innerHeight/2) : new THREE.Vector2(window.innerWidth, window.innerHeight);
            const bloomPass = new UnrealBloomPass(bloomResolution, 1.5, 0.4, 0.85);
            bloomPass.threshold = 0.1;
            bloomPass.strength = isMobile ? 1.2 : 1.5;
            bloomPass.radius = 0.6;

            composer = new EffectComposer(renderer);
            composer.addPass(renderScene);
            composer.addPass(bloomPass);

            await prepareTextGeometry();

            animate();
            initMediaPipe();

            const loader = document.getElementById('loading-screen');
            loader.style.opacity = '0';
            setTimeout(() => loader.remove(), 700);

            window.addEventListener('resize', onWindowResize, false);
        }

        // --- SHAPE GENERATORS ---

        function setShapeRainbow() {
            const color = new THREE.Color();
            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const phi = Math.acos(-1 + (2 * i) / PARTICLE_COUNT);
                const theta = Math.sqrt(PARTICLE_COUNT * Math.PI) * phi;
                const r = 12 + Math.random() * 4;

                targetPositions[i * 3] = r * Math.cos(theta) * Math.sin(phi);
                targetPositions[i * 3 + 1] = r * Math.sin(theta) * Math.sin(phi);
                targetPositions[i * 3 + 2] = r * Math.cos(phi);

                color.setHSL((i / PARTICLE_COUNT + Date.now()*0.0001)%1, 0.8, 0.6);
                targetColors[i * 3] = color.r;
                targetColors[i * 3 + 1] = color.g;
                targetColors[i * 3 + 2] = color.b;
            }
        }

        function setShapeSaturn() {
            const planetColor = new THREE.Color(0x2255ff).multiplyScalar(1.2);
            const ringColor = new THREE.Color(0xffaa00).multiplyScalar(1.2);
            const sphereCount = Math.floor(PARTICLE_COUNT * 0.35);
            
            for (let i = 0; i < PARTICLE_COUNT; i++) {
                if (i < sphereCount) {
                    const phi = Math.acos(-1 + (2 * i) / sphereCount);
                    const theta = Math.sqrt(sphereCount * Math.PI) * phi;
                    const r = 7;
                    targetPositions[i*3] = r * Math.cos(theta) * Math.sin(phi);
                    targetPositions[i*3+1] = r * Math.sin(theta) * Math.sin(phi);
                    targetPositions[i*3+2] = r * Math.cos(phi);
                    targetColors[i*3] = planetColor.r; targetColors[i*3+1] = planetColor.g; targetColors[i*3+2] = planetColor.b;
                } else {
                    const angle = Math.random() * Math.PI * 2;
                    const radius = 10 + Math.random() * 8;
                    const x = radius * Math.cos(angle);
                    const z = radius * Math.sin(angle);
                    const tilt = 0.4;
                    targetPositions[i*3] = x;
                    targetPositions[i*3+1] = z * Math.sin(tilt);
                    targetPositions[i*3+2] = z * Math.cos(tilt);
                    targetColors[i*3] = ringColor.r; targetColors[i*3+1] = ringColor.g; targetColors[i*3+2] = ringColor.b;
                }
            }
        }

        function setShapeHeart() {
            const color = new THREE.Color(0xff0055).multiplyScalar(1.5);
            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const t = Math.random() * Math.PI * 2;
                let x = 16 * Math.pow(Math.sin(t), 3);
                let y = 13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t);
                let z = (Math.random() - 0.5) * 6;
                const r = Math.random() * 0.2 + 0.8; // Concentrate points slightly towards shell
                x *= r; y *= r; z *= r;
                const scale = 0.9;
                targetPositions[i*3] = x * scale;
                targetPositions[i*3+1] = y * scale;
                targetPositions[i*3+2] = z * scale;
                targetColors[i*3] = color.r; targetColors[i*3+1] = color.g; targetColors[i*3+2] = color.b;
            }
        }

        // --- IMPROVED TEXT LOGIC (CLARITY FOCUS) ---
        async function prepareTextGeometry() {
            const loader = new FontLoader();
            return new Promise((resolve) => {
                loader.load('https://unpkg.com/three@0.160.0/examples/fonts/helvetiker_bold.typeface.json', function (font) {
                    
                    // KEY CHANGE FOR CLARITY: Very thin height (0.4) forces particles to the front face.
                    const textGeo = new TextGeometry('I LOVE YOU\nWULAN', {
                        font: font,
                        size: 3.5,
                        height: 0.4, // <-- CRITICAL: Makes text "thin" so particles don't get lost on sides
                        curveSegments: 8,
                        bevelEnabled: true,
                        bevelThickness: 0.1,
                        bevelSize: 0.05,
                        bevelOffset: 0,
                        bevelSegments: 3
                    });

                    textGeo.center();

                    const mesh = new THREE.Mesh(textGeo, new THREE.MeshBasicMaterial());
                    const sampler = new MeshSurfaceSampler(mesh).build();

                    textPointsCache = new Float32Array(PARTICLE_COUNT * 3);
                    const tempVec = new THREE.Vector3();

                    for (let i = 0; i < PARTICLE_COUNT; i++) {
                        sampler.sample(tempVec);
                        textPointsCache[i * 3] = tempVec.x;
                        textPointsCache[i * 3 + 1] = tempVec.y;
                        // We will add artificial Z-depth in setShapeText instead of relying on geometry thickness
                        textPointsCache[i * 3 + 2] = tempVec.z; 
                    }
                    resolve();
                });
            });
        }

        function setShapeText() {
            if (!textPointsCache) return;
            // Brighter Gold/Orange
            const color = new THREE.Color(0xffcc00).multiplyScalar(1.3); 
            
            for (let i = 0; i < PARTICLE_COUNT; i++) {
                targetPositions[i * 3] = textPointsCache[i * 3];
                targetPositions[i * 3 + 1] = textPointsCache[i * 3 + 1];
                
                // KEY CHANGE FOR CLARITY V2:
                // Add artificial Z-depth noise. This makes the thin geometry look volumetric
                // without sacrificing readability on the front face.
                const zNoise = (Math.random() - 0.5) * 2.5; 
                targetPositions[i * 3 + 2] = textPointsCache[i * 3 + 2] + zNoise;

                targetColors[i * 3] = color.r;
                targetColors[i * 3 + 1] = color.g;
                targetColors[i * 3 + 2] = color.b;
            }
        }

        // --- MEDIAPIPE ---
        function initMediaPipe() {
            const videoElement = document.getElementById('webcam-preview');
            const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
            
            hands.setOptions({
                maxNumHands: 1,
                modelComplexity: 0,
                minDetectionConfidence: 0.5,
                minTrackingConfidence: 0.5
            });

            hands.onResults((results) => {
                const status = document.getElementById('tracking-status');
                if(results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                    status.className = "absolute bottom-1 right-1 w-2 h-2 bg-green-500 rounded-full";
                    detectGesture(results.multiHandLandmarks[0]);
                } else {
                    status.className = "absolute bottom-1 right-1 w-2 h-2 bg-red-500 rounded-full";
                }
            });

            const cameraUtils = new Camera(videoElement, {
                onFrame: async () => { await hands.send({image: videoElement}); },
                width: 640, height: 480
            });
            cameraUtils.start();
        }

        function detectGesture(landmarks) {
            if(isAIActive) return;

            const label = document.getElementById('gesture-label');
            const gestureBox = document.getElementById('gesture-box');
            
            const indexUp = landmarks[8].y < landmarks[6].y;
            const middleUp = landmarks[12].y < landmarks[10].y;
            const ringUp = landmarks[16].y < landmarks[14].y;
            const pinkyUp = landmarks[20].y < landmarks[18].y;
            const dHeart = Math.hypot(landmarks[4].x - landmarks[8].x, landmarks[4].y - landmarks[8].y);
            
            let newShape = currentShape;
            let newLabel = label.innerText;
            let colorClass = "";

            if (dHeart < 0.06 && !middleUp) {
                newShape = 'heart'; newLabel = "HEART"; colorClass = "text-pink-500";
            } else if (!indexUp && !middleUp && !ringUp && !pinkyUp) {
                newShape = 'saturn'; newLabel = "SATURN"; colorClass = "text-blue-500";
            } else if (indexUp && middleUp && !ringUp && !pinkyUp) {
                newShape = 'text'; 
                newLabel = "I LOVE YOU WULAN"; // Update Label
                colorClass = "text-yellow-400 font-extrabold";
            } else if (indexUp && middleUp && ringUp && pinkyUp) {
                newShape = 'rainbow'; newLabel = "RAINBOW"; colorClass = "text-purple-400";
            }

            if (newShape !== currentShape) {
                currentShape = newShape;
                label.innerText = newLabel;
                label.className = `text-sm ${colorClass} leading-tight`;
                
                // UI Pop effect for Text mode
                if(newShape === 'text') {
                     gestureBox.classList.add('bg-yellow-400/20', 'scale-105');
                     setTimeout(() => gestureBox.classList.remove('scale-105'), 200);
                } else {
                     gestureBox.classList.remove('bg-yellow-400/20');
                }

                if(currentShape === 'heart') setShapeHeart();
                if(currentShape === 'saturn') setShapeSaturn();
                if(currentShape === 'text') setShapeText();
                if(currentShape === 'rainbow') setShapeRainbow();
            }
        }

        // --- AI LOGIC (Unchanged) ---
        window.toggleMagicModal = () => {
            const modal = document.getElementById('magic-modal');
            const content = document.getElementById('magic-content');
            if(modal.classList.contains('hidden')) {
                modal.classList.remove('hidden');
                setTimeout(() => { content.classList.remove('scale-95', 'opacity-0'); content.classList.add('scale-100', 'opacity-100'); }, 10);
            } else {
                content.classList.remove('scale-100', 'opacity-100'); content.classList.add('scale-95', 'opacity-0');
                setTimeout(() => modal.classList.add('hidden'), 300);
            }
        }

        window.generateAI = async () => {
            const key = document.getElementById('gemini-key').value;
            const prompt = document.getElementById('ai-prompt').value;
            const btn = document.getElementById('generate-btn');
            if(!key || !prompt) return alert("API Key & Prompt required!");
            btn.innerText = "THINKING..."; btn.disabled = true;
            const systemPrompt = `Generate JS loop code for particle positions (x,y,z) and colors (r,g,b) for shape: "${prompt}". Context: Loop variable 'i' from 0 to 'count'. Arrays 'targetPositions', 'targetColors'. Radius approx 15. Output raw math code only. No functions.`;
            try {
                const res = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash:generateContent?key=${key}`, { method: 'POST', headers: {'Content-Type': 'application/json'}, body: JSON.stringify({contents: [{parts: [{text: systemPrompt}]}]}) });
                const data = await res.json();
                let code = data.candidates[0].content.parts[0].text.replace(/```javascript|```/g, '').trim();
                const f = new Function('targetPositions', 'targetColors', 'count', `for(let i=0; i<count; i++) { ${code} }`);
                f(targetPositions, targetColors, PARTICLE_COUNT);
                isAIActive = true; currentShape = 'ai'; toggleMagicModal(); document.getElementById('gesture-label').innerText = "AI GENERATED";
            } catch(e) { alert("Error: Check API Key"); } finally { btn.innerText = "GENERATE"; btn.disabled = false; }
        }

        function animate() {
            requestAnimationFrame(animate);
            const positionsAttribute = geometry.attributes.position;
            const colorsAttribute = geometry.attributes.color;

            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const idx = i * 3;
                positions[idx] += (targetPositions[idx] - positions[idx]) * LERP_SPEED;
                positions[idx+1] += (targetPositions[idx+1] - positions[idx+1]) * LERP_SPEED;
                positions[idx+2] += (targetPositions[idx+2] - positions[idx+2]) * LERP_SPEED;
                colors[idx] += (targetColors[idx] - colors[idx]) * LERP_SPEED;
                colors[idx+1] += (targetColors[idx+1] - colors[idx+1]) * LERP_SPEED;
                colors[idx+2] += (targetColors[idx+2] - colors[idx+2]) * LERP_SPEED;
            }
            positionsAttribute.needsUpdate = true; colorsAttribute.needsUpdate = true;
            points.rotation.y += 0.002; // Slow rotation
            composer.render();
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        }
        window.toggleFullScreen = () => { !document.fullscreenElement ? document.documentElement.requestFullscreen() : document.exitFullscreen(); }

        init();
    </script>
</body>
</html>
