<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gesture Particles + Gemini AI</title>

    <script src="https://cdn.tailwindcss.com"></script>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Inter', sans-serif; }
        
        /* Glassmorphism Classes */
        .glass {
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        /* Mirrored Video for Preview */
        #webcam-preview {
            transform: scaleX(-1);
            object-fit: cover;
        }

        canvas { display: block; }

        /* Loader Animation */
        .loader {
            border: 4px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            border-top: 4px solid #fff;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
    </style>
</head>
<body class="text-white">

    <div id="loading-screen" class="fixed inset-0 z-50 flex flex-col items-center justify-center bg-black transition-opacity duration-700">
        <div class="loader mb-4"></div>
        <h2 class="text-xl font-light tracking-widest animate-pulse">INITIALIZING SYSTEMS</h2>
        <p class="text-xs text-gray-500 mt-2">Loading Three.js, Fonts, & AI Models...</p>
    </div>

    <div class="fixed top-0 left-0 w-full h-full pointer-events-none z-10 p-6 flex flex-col justify-between">
        
        <div class="flex justify-between items-start pointer-events-auto">
            <div class="glass p-4 rounded-xl">
                <h1 class="text-xl font-bold bg-clip-text text-transparent bg-gradient-to-r from-blue-400 to-purple-500">
                    PARTICLE<span class="font-light text-white">GENESIS</span>
                </h1>
                <div class="mt-2 text-xs text-gray-400 flex flex-col gap-1">
                    <span>üñê Open: Rainbow Sphere</span>
                    <span>‚úä Fist: Saturn</span>
                    <span>‚úåÔ∏è V-Sign: "I LOVE YOU"</span>
                    <span>ü§å Finger Heart: Heart</span>
                </div>
            </div>

            <div class="glass p-1 rounded-xl overflow-hidden w-32 h-24 relative">
                <video id="webcam-preview" class="w-full h-full bg-black"></video>
                <div class="absolute bottom-1 right-1 w-3 h-3 bg-red-500 rounded-full animate-pulse" id="tracking-status"></div>
            </div>
        </div>

        <div class="flex justify-between items-end pointer-events-auto">
            <div class="glass px-6 py-3 rounded-full flex items-center gap-4">
                <span class="text-xs text-gray-400 uppercase tracking-wider">Detected:</span>
                <span id="gesture-label" class="text-lg font-bold text-yellow-400">WAITING...</span>
            </div>

            <div class="flex gap-3">
                <button onclick="toggleMagicModal()" class="glass hover:bg-white/10 transition px-5 py-2 rounded-lg flex items-center gap-2 group">
                    <span class="text-xl">‚ú®</span>
                    <span class="font-semibold group-hover:text-purple-300">AI Magic</span>
                </button>
                <button onclick="toggleFullScreen()" class="glass hover:bg-white/10 transition p-3 rounded-lg">
                    <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 8V4m0 0h4M4 4l5 5m11-1V4m0 0h-4m4 4l-5 5M4 16v4m0 0h4m-4 0l5-5m11 5l-5-5m5 5v-4m0 4h-4"></path></svg>
                </button>
            </div>
        </div>
    </div>

    <div id="magic-modal" class="fixed inset-0 z-40 bg-black/80 backdrop-blur-md hidden flex items-center justify-center">
        <div class="glass p-8 rounded-2xl max-w-md w-full relative transform transition-all scale-95 opacity-0" id="magic-content">
            <button onclick="toggleMagicModal()" class="absolute top-4 right-4 text-gray-400 hover:text-white">‚úï</button>
            
            <h2 class="text-2xl font-bold mb-1">AI Particle Weaver</h2>
            <p class="text-sm text-gray-400 mb-6">Powered by Google Gemini</p>

            <div class="space-y-4">
                <div>
                    <label class="block text-xs font-mono text-gray-500 mb-1">API KEY (Required)</label>
                    <input type="password" id="gemini-key" placeholder="Paste your Gemini API Key here" class="w-full bg-black/50 border border-gray-700 rounded p-3 text-white focus:border-purple-500 outline-none transition">
                </div>

                <div>
                    <label class="block text-xs font-mono text-gray-500 mb-1">PROMPT</label>
                    <input type="text" id="ai-prompt" placeholder="e.g., 'Spiral DNA helix with neon colors'" class="w-full bg-black/50 border border-gray-700 rounded p-3 text-white focus:border-purple-500 outline-none transition">
                </div>

                <button onclick="generateAI()" id="generate-btn" class="w-full bg-gradient-to-r from-blue-600 to-purple-600 hover:from-blue-500 hover:to-purple-500 text-white font-bold py-3 rounded-lg transition shadow-lg shadow-purple-900/20">
                    GENERATE SPELL
                </button>
            </div>
        </div>
    </div>

    <div id="canvas-container" class="absolute inset-0 z-0"></div>

    <script type="module">
        import * as THREE from 'three';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { FontLoader } from 'three/addons/loaders/FontLoader.js';
        import { TextGeometry } from 'three/addons/geometries/TextGeometry.js';
        import { MeshSurfaceSampler } from 'three/addons/math/MeshSurfaceSampler.js';

        // --- Configuration ---
        const PARTICLE_COUNT = 20000;
        const CAM_Z = 35;
        const LERP_SPEED = 0.08;

        // --- State ---
        let scene, camera, renderer, composer, geometry, points;
        let positions, colors, targetPositions, targetColors;
        let textPointsCache = null; // Cache for the heavy text calculation
        let currentShape = 'rainbow'; // initial shape
        let isAIActive = false;
        
        // --- Initialization ---
        async function init() {
            // Scene Setup
            const container = document.getElementById('canvas-container');
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x000000, 0.002);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = CAM_Z;

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            container.appendChild(renderer.domElement);

            // Particles Setup
            positions = new Float32Array(PARTICLE_COUNT * 3);
            colors = new Float32Array(PARTICLE_COUNT * 3);
            targetPositions = new Float32Array(PARTICLE_COUNT * 3);
            targetColors = new Float32Array(PARTICLE_COUNT * 3);

            // Initialize Rainbow Sphere
            setShapeRainbow();
            // Copy targets to current for start
            for(let i=0; i<PARTICLE_COUNT*3; i++) {
                positions[i] = targetPositions[i];
                colors[i] = targetColors[i];
            }

            geometry = new THREE.BufferGeometry();
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

            const material = new THREE.PointsMaterial({
                size: 0.15,
                vertexColors: true,
                blending: THREE.AdditiveBlending,
                depthWrite: false,
                transparent: true,
                opacity: 0.9
            });

            points = new THREE.Points(geometry, material);
            scene.add(points);

            // Post Processing (BLOOM)
            const renderScene = new RenderPass(scene, camera);
            const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
            bloomPass.threshold = 0;
            bloomPass.strength = 1.2;
            bloomPass.radius = 0.5;

            composer = new EffectComposer(renderer);
            composer.addPass(renderScene);
            composer.addPass(bloomPass);

            // Pre-calculate Text Geometry (Async)
            await prepareTextGeometry();

            // Start Animation Loop
            animate();

            // Start MediaPipe
            initMediaPipe();

            // Remove loading screen
            const loader = document.getElementById('loading-screen');
            loader.style.opacity = '0';
            setTimeout(() => loader.remove(), 700);

            // Handle Resize
            window.addEventListener('resize', onWindowResize, false);
        }

        // --- Shape Logic ---

        function setShapeRainbow() {
            const color = new THREE.Color();
            for (let i = 0; i < PARTICLE_COUNT; i++) {
                // Sphere math
                const phi = Math.acos(-1 + (2 * i) / PARTICLE_COUNT);
                const theta = Math.sqrt(PARTICLE_COUNT * Math.PI) * phi;
                const r = 10 + Math.random() * 2; // Radius with noise

                const x = r * Math.cos(theta) * Math.sin(phi);
                const y = r * Math.sin(theta) * Math.sin(phi);
                const z = r * Math.cos(phi);

                targetPositions[i * 3] = x;
                targetPositions[i * 3 + 1] = y;
                targetPositions[i * 3 + 2] = z;

                // Rainbow colors
                color.setHSL(i / PARTICLE_COUNT, 1.0, 0.5);
                targetColors[i * 3] = color.r;
                targetColors[i * 3 + 1] = color.g;
                targetColors[i * 3 + 2] = color.b;
            }
        }

        function setShapeSaturn() {
            const planetColor = new THREE.Color(0x3366ff); // Blue
            const ringColor = new THREE.Color(0xffd700);   // Gold

            const sphereCount = Math.floor(PARTICLE_COUNT * 0.4);
            const ringCount = PARTICLE_COUNT - sphereCount;

            // Sphere
            for (let i = 0; i < sphereCount; i++) {
                const phi = Math.acos(-1 + (2 * i) / sphereCount);
                const theta = Math.sqrt(sphereCount * Math.PI) * phi;
                const r = 6;

                targetPositions[i * 3] = r * Math.cos(theta) * Math.sin(phi);
                targetPositions[i * 3 + 1] = r * Math.sin(theta) * Math.sin(phi);
                targetPositions[i * 3 + 2] = r * Math.cos(phi);

                targetColors[i * 3] = planetColor.r;
                targetColors[i * 3 + 1] = planetColor.g;
                targetColors[i * 3 + 2] = planetColor.b;
            }

            // Rings
            for (let i = sphereCount; i < PARTICLE_COUNT; i++) {
                const idx = i - sphereCount;
                const angle = (idx / ringCount) * Math.PI * 2 * 15; // multiple spirals
                const radius = 9 + Math.random() * 6; // Ring width 9 to 15

                // Tilt calculation
                const x0 = radius * Math.cos(angle);
                const z0 = radius * Math.sin(angle);
                
                // Tilt by 30 degrees around X
                const tilt = 0.5; 
                const x = x0;
                const y = z0 * Math.sin(tilt);
                const z = z0 * Math.cos(tilt);

                targetPositions[i * 3] = x;
                targetPositions[i * 3 + 1] = y;
                targetPositions[i * 3 + 2] = z;

                targetColors[i * 3] = ringColor.r;
                targetColors[i * 3 + 1] = ringColor.g;
                targetColors[i * 3 + 2] = ringColor.b;
            }
        }

        function setShapeHeart() {
            const color = new THREE.Color(0xff0066); // Hot pink
            for (let i = 0; i < PARTICLE_COUNT; i++) {
                // Heart Surface Math
                // Use parametric equations or random sampling inside volumes
                // Simple parametric line curve:
                // x = 16sin^3(t)
                // y = 13cos(t) - 5cos(2t) - 2cos(3t) - cos(4t)
                
                // Let's do a 3D volume heart roughly
                const t = Math.random() * Math.PI * 2;
                const u = Math.random(); // volume fill
                
                // Heart curve base
                let x = 16 * Math.pow(Math.sin(t), 3);
                let y = 13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t);
                
                // Add Z-depth
                let z = (Math.random() - 0.5) * 5; 
                
                // Scale down
                const scale = 0.8;
                x *= scale;
                y *= scale;
                
                // Fill factor
                const spread = Math.random() * 0.5;
                
                targetPositions[i * 3] = x + (Math.random()-0.5);
                targetPositions[i * 3 + 1] = y + (Math.random()-0.5);
                targetPositions[i * 3 + 2] = z * (2 - Math.abs(y)/10); // taper at bottom

                targetColors[i * 3] = color.r;
                targetColors[i * 3 + 1] = color.g;
                targetColors[i * 3 + 2] = color.b;
            }
        }

        // Function to sample text surface efficiently
        async function prepareTextGeometry() {
            const loader = new FontLoader();
            // Using a standard font from three.js examples
            return new Promise((resolve) => {
                loader.load('https://unpkg.com/three@0.160.0/examples/fonts/helvetiker_bold.typeface.json', function (font) {
                    const textGeo = new TextGeometry('I LOVE YOU', {
                        font: font,
                        size: 3,
                        height: 1, // Thickness
                        curveSegments: 12,
                        bevelEnabled: true,
                        bevelThickness: 0.1,
                        bevelSize: 0.05,
                        bevelOffset: 0,
                        bevelSegments: 5
                    });

                    textGeo.center(); // Center the text

                    // Create MeshSurfaceSampler
                    const mesh = new THREE.Mesh(textGeo, new THREE.MeshBasicMaterial());
                    const sampler = new MeshSurfaceSampler(mesh).build();

                    textPointsCache = new Float32Array(PARTICLE_COUNT * 3);
                    const tempVec = new THREE.Vector3();

                    for (let i = 0; i < PARTICLE_COUNT; i++) {
                        sampler.sample(tempVec);
                        textPointsCache[i * 3] = tempVec.x;
                        textPointsCache[i * 3 + 1] = tempVec.y;
                        textPointsCache[i * 3 + 2] = tempVec.z;
                    }
                    resolve();
                });
            });
        }

        function setShapeText() {
            if (!textPointsCache) return;
            const color = new THREE.Color(0xffd700); // Gold

            for (let i = 0; i < PARTICLE_COUNT; i++) {
                targetPositions[i * 3] = textPointsCache[i * 3];
                targetPositions[i * 3 + 1] = textPointsCache[i * 3 + 1];
                targetPositions[i * 3 + 2] = textPointsCache[i * 3 + 2];

                targetColors[i * 3] = color.r;
                targetColors[i * 3 + 1] = color.g;
                targetColors[i * 3 + 2] = color.b;
            }
        }

        // --- MediaPipe Logic ---
        function initMediaPipe() {
            const videoElement = document.getElementById('webcam-preview');
            
            const hands = new Hands({locateFile: (file) => {
                return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
            }});
            
            hands.setOptions({
                maxNumHands: 1,
                modelComplexity: 1,
                minDetectionConfidence: 0.5,
                minTrackingConfidence: 0.5
            });

            hands.onResults(onHandsResults);

            const cameraUtils = new Camera(videoElement, {
                onFrame: async () => {
                    await hands.send({image: videoElement});
                },
                width: 640,
                height: 480
            });
            cameraUtils.start();
        }

        function onHandsResults(results) {
            const statusDot = document.getElementById('tracking-status');
            const label = document.getElementById('gesture-label');

            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                statusDot.classList.remove('bg-red-500');
                statusDot.classList.add('bg-green-500');
                
                const landmarks = results.multiHandLandmarks[0];
                detectGesture(landmarks, label);
            } else {
                statusDot.classList.remove('bg-green-500');
                statusDot.classList.add('bg-red-500');
                // Optional: revert to Rainbow if no hand, or just stay
                // label.innerText = "NO HAND";
            }
        }

        function detectGesture(landmarks, labelEl) {
            if (isAIActive) {
                labelEl.innerText = "AI CONTROL";
                return; 
            }

            // Finger State Helpers
            const isThumbOpen = landmarks[4].x < landmarks[3].x; // Assuming right hand logic approx for demo, simpler distance check is better
            // Better Logic: Is finger tip above pip? (Y-axis inverted in MediaPipe usually)
            
            // Helper to check extension based on Y coordinates
            // Tip y < PIP y means finger is UP (since 0 is top)
            const indexUp = landmarks[8].y < landmarks[6].y;
            const middleUp = landmarks[12].y < landmarks[10].y;
            const ringUp = landmarks[16].y < landmarks[14].y;
            const pinkyUp = landmarks[20].y < landmarks[18].y;

            // Distance for Finger Heart
            // Distance between Thumb Tip (4) and Index Tip (8)
            const dx = landmarks[4].x - landmarks[8].x;
            const dy = landmarks[4].y - landmarks[8].y;
            const dist = Math.sqrt(dx*dx + dy*dy);

            let newShape = currentShape;

            // 1. Finger Heart (Thumb & Index close, others down usually, but we'll accept just tips close)
            if (dist < 0.05) {
                labelEl.innerText = "FINGER HEART";
                labelEl.className = "text-lg font-bold text-pink-400";
                if(currentShape !== 'heart') {
                    setShapeHeart();
                    currentShape = 'heart';
                }
                return;
            }

            // 2. Fist (All fingers down)
            if (!indexUp && !middleUp && !ringUp && !pinkyUp) {
                labelEl.innerText = "FIST (SATURN)";
                labelEl.className = "text-lg font-bold text-blue-400";
                if(currentShape !== 'saturn') {
                    setShapeSaturn();
                    currentShape = 'saturn';
                }
                return;
            }

            // 3. V-Sign (Index & Middle Up, Ring & Pinky Down)
            if (indexUp && middleUp && !ringUp && !pinkyUp) {
                labelEl.innerText = "PEACE (I LOVE YOU)";
                labelEl.className = "text-lg font-bold text-yellow-400";
                if(currentShape !== 'text') {
                    setShapeText();
                    currentShape = 'text';
                }
                return;
            }

            // 4. Open Hand (All Up)
            if (indexUp && middleUp && ringUp && pinkyUp) {
                labelEl.innerText = "OPEN (RAINBOW)";
                labelEl.className = "text-lg font-bold text-purple-400";
                if(currentShape !== 'rainbow') {
                    setShapeRainbow();
                    currentShape = 'rainbow';
                }
                return;
            }
        }

        // --- Gemini AI Logic ---
        
        window.toggleMagicModal = () => {
            const modal = document.getElementById('magic-modal');
            const content = document.getElementById('magic-content');
            if(modal.classList.contains('hidden')) {
                modal.classList.remove('hidden');
                // Trigger reflow
                void modal.offsetWidth;
                content.classList.remove('scale-95', 'opacity-0');
                content.classList.add('scale-100', 'opacity-100');
            } else {
                content.classList.remove('scale-100', 'opacity-100');
                content.classList.add('scale-95', 'opacity-0');
                setTimeout(() => modal.classList.add('hidden'), 200);
            }
        }

        window.generateAI = async () => {
            const key = document.getElementById('gemini-key').value;
            const promptText = document.getElementById('ai-prompt').value;
            const btn = document.getElementById('generate-btn');

            if(!key) { alert("Please enter API Key"); return; }
            if(!promptText) { alert("Please enter a prompt"); return; }

            btn.innerText = "CONJURING...";
            btn.disabled = true;

            const systemPrompt = `
            You are a JavaScript Particle Effect Generator. 
            You must output ONLY raw JavaScript code inside a loop.
            
            Context:
            - Variable 'i' loops from 0 to 'count' (20000).
            - Arrays: 'targetPositions' (size count*3) and 'targetColors' (size count*3).
            - Access positions via: targetPositions[i*3], targetPositions[i*3+1], targetPositions[i*3+2].
            - Access colors via: targetColors[i*3], targetColors[i*3+1], targetColors[i*3+2] (Values 0.0 to 1.0).
            - Math functions available via Math object.
            
            Task:
            Write the code INSIDE the for-loop to calculate x, y, z and r, g, b based on this description: "${promptText}".
            Scale the shape to be roughly roughly size 15 to 20 units.
            
            Constraint:
            - DO NOT return function declarations.
            - DO NOT return the for loop itself.
            - DO NOT return markdown backticks.
            - ONLY return the math logic lines.
            `;

            try {
                const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash:generateContent?key=${key}`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        contents: [{ parts: [{ text: systemPrompt }] }]
                    })
                });

                const data = await response.json();
                let code = data.candidates[0].content.parts[0].text;
                
                // Cleanup Markdown if Gemini adds it despite instructions
                code = code.replace(/```javascript/g, '').replace(/```/g, '').trim();

                console.log("AI Code:", code);

                // Execute Code
                const particleFunc = new Function('targetPositions', 'targetColors', 'count', `
                    for(let i=0; i<count; i++) {
                        ${code}
                    }
                `);

                particleFunc(targetPositions, targetColors, PARTICLE_COUNT);
                
                isAIActive = true;
                currentShape = 'ai';
                toggleMagicModal();
                document.getElementById('gesture-label').innerText = "AI GENERATED";

            } catch (e) {
                console.error(e);
                alert("Spell fizzled out. Check console/API Key.");
            } finally {
                btn.innerText = "GENERATE SPELL";
                btn.disabled = false;
            }
        }

        // --- Render Loop ---

        function animate() {
            requestAnimationFrame(animate);

            // Lerp Particles
            const positionsAttribute = geometry.attributes.position;
            const colorsAttribute = geometry.attributes.color;

            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const idx = i * 3;
                
                // Position Interpolation
                positions[idx] += (targetPositions[idx] - positions[idx]) * LERP_SPEED;
                positions[idx+1] += (targetPositions[idx+1] - positions[idx+1]) * LERP_SPEED;
                positions[idx+2] += (targetPositions[idx+2] - positions[idx+2]) * LERP_SPEED;

                // Color Interpolation
                colors[idx] += (targetColors[idx] - colors[idx]) * LERP_SPEED;
                colors[idx+1] += (targetColors[idx+1] - colors[idx+1]) * LERP_SPEED;
                colors[idx+2] += (targetColors[idx+2] - colors[idx+2]) * LERP_SPEED;
            }

            positionsAttribute.needsUpdate = true;
            colorsAttribute.needsUpdate = true;

            // Slow rotation for 3D feel
            if (points) {
                points.rotation.y += 0.002;
                if(currentShape === 'saturn') {
                   // Add specific wobble for saturn?
                }
            }

            composer.render();
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        }
        
        window.toggleFullScreen = () => {
            if (!document.fullscreenElement) {
                document.documentElement.requestFullscreen();
            } else {
                if (document.exitFullscreen) {
                    document.exitFullscreen();
                }
            }
        };

        // Initialize App
        init();

    </script>
</body>
</html>
